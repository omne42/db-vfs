#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

staged_status="$(git diff --cached --name-status --diff-filter=ACMRD || true)"
staged_files="$(printf '%s\n' "$staged_status" | awk '{print $2}')"
if [[ -z "${staged_files//[[:space:]]/}" ]]; then
  exit 0
fi

has_changelog=0
changelog_deleted=0
other_count=0
while IFS=$'\t' read -r status path _rest; do
  [[ -z "$path" ]] && continue
  if [[ "$path" == "CHANGELOG.md" ]]; then
    if [[ "$status" == "D" ]]; then
      changelog_deleted=1
    else
      has_changelog=1
    fi
  else
    other_count=$((other_count + 1))
  fi
done <<<"$staged_status"

if [[ "$changelog_deleted" -eq 1 ]]; then
  echo "pre-commit: deleting CHANGELOG.md is not allowed." >&2
  exit 1
fi

if [[ "$has_changelog" -ne 1 ]]; then
  cat >&2 <<'EOF'
pre-commit: CHANGELOG.md must be updated in the same commit.

- Add an entry under [Unreleased] in CHANGELOG.md.
- Stage it: git add CHANGELOG.md
EOF
  exit 1
fi

if [[ "$other_count" -eq 0 ]]; then
  echo "pre-commit: refusing changelog-only commit; commit the actual change together with CHANGELOG.md." >&2
  exit 1
fi

if [[ "${DB_VFS_ALLOW_CHANGELOG_RELEASE_EDIT:-}" != "1" ]]; then
  head_changelog="$(git show HEAD:CHANGELOG.md 2>/dev/null || true)"
  index_changelog="$(git show :CHANGELOG.md 2>/dev/null || true)"

  if [[ -n "${head_changelog}" && -n "${index_changelog}" ]]; then
    head_released="$(printf '%s\n' "${head_changelog}" | awk 'BEGIN{s=0} /^## \\[[0-9]/{s=1} s{print}')"
    index_released="$(printf '%s\n' "${index_changelog}" | awk 'BEGIN{s=0} /^## \\[[0-9]/{s=1} s{print}')"

    if [[ "${head_released}" != "${index_released}" ]]; then
      cat >&2 <<'EOF'
pre-commit: refusing to modify released CHANGELOG sections.

Only edit entries under [Unreleased]. Released version sections (e.g. [0.x.y]) are immutable.

If you are cutting a release and intentionally updating versioned sections, re-run with:
  DB_VFS_ALLOW_CHANGELOG_RELEASE_EDIT=1 git commit ...
EOF
      exit 1
    fi
  fi
fi

max_rs_lines="${DB_VFS_MAX_RS_LINES:-1000}"
if ! [[ "$max_rs_lines" =~ ^[1-9][0-9]*$ ]]; then
  echo "pre-commit: DB_VFS_MAX_RS_LINES must be a positive integer (got: $max_rs_lines)" >&2
  exit 1
fi

offenders=()
staged_rs_files="$(git diff --cached --name-only --diff-filter=AM -- '*.rs' || true)"
while IFS= read -r path; do
  [[ -z "$path" ]] && continue
  lines="$(git show ":$path" 2>/dev/null | awk 'END{print NR}')"
  if [[ "${lines:-0}" -gt "$max_rs_lines" ]]; then
    offenders+=("$path ($lines)")
  fi
done <<<"$staged_rs_files"

if [[ "${#offenders[@]}" -gt 0 ]]; then
  cat >&2 <<EOF
pre-commit: refusing to commit oversized Rust files.

一个良好的代码仓库不应该有超过 ${max_rs_lines} 行的 Rust 文件，这意味着复杂度过度或没有良好的领域分割；请拆分模块，否则禁止提交。

以下 Rust 文件超过 ${max_rs_lines} 行：
$(printf '  - %s\n' "${offenders[@]}")

如果你确实需要临时放宽限制，可设置：
  DB_VFS_MAX_RS_LINES=<N> git commit ...
EOF
  exit 1
fi

gate_script="$repo_root/scripts/gate.sh"
if [[ ! -x "$gate_script" ]]; then
  echo "pre-commit: missing gate script: $gate_script" >&2
  exit 1
fi

"$gate_script"
