---
title: db-vfs docs bundle
description: DB-backed virtual filesystem with explicit Policy + Secrets + Limits, plus an HTTP service.
tags: [rust, sqlite, postgres, vfs, security, policy, http]
---

# db-vfs — LLM documentation bundle

This file is generated from the repo sources to make RAG/LLM ingestion easier.
It follows `docs/src/SUMMARY.md` for the docs ordering.

Update it by running:

  ./scripts/llms.sh

---
file: README.md
---

# db-vfs

DB-backed “virtual filesystem” (DB-VFS) intended for server / high-concurrency workloads.

Goals:

- Preserve the explicit safety model shape: **Policy + Secrets + Limits**.
- Provide tool-like operations: `read`, `glob`, `grep`, `write`, `patch`, `delete`.
- Support SQLite (dev/test) and Postgres (production).

This is intentionally *not* part of `safe-fs-tools` to keep that crate focused on local OS
filesystem semantics and a small dependency graph.

## Documentation

- Human docs (mdBook sources): `docs/` (build with `./scripts/docs.sh`)
- LLM/RAG bundle: `llms.txt` and `docs/llms.txt` (regenerate with `./scripts/llms.sh`)

## Semantics

- `workspace_id` is the namespace boundary (like a “workspace root”).
- All `path`/`path_prefix` values are **root-relative**:
  - Must not start with `/`
  - Must not contain `..`
  - Must not have leading/trailing whitespace
  - `path_prefix` may be empty (`""`) to mean “the whole workspace” **only if**
    `policy.permissions.allow_full_scan = true`
- Scope control (`path_prefix`):
  - `grep` requires an explicit `path_prefix` unless a safe literal prefix can be derived from
    `glob` (e.g. `"docs/**/*.md"` → `"docs/"`).
  - `glob` similarly requires `path_prefix` for broad patterns without a safe literal prefix (e.g.
    `"**/*.md"`).
- `grep.query` must be non-empty (empty query is rejected).
- Concurrency control (`expected_version` / CAS):
  - `read` returns a `version`.
  - `patch` requires `expected_version`.
  - `write(expected_version = None)` is **create-only**; updates require `expected_version`.
  - `delete(expected_version = Some(v))` enforces CAS; `delete(expected_version = None)` is
    unconditional.
- Redaction and limits:
  - `read.bytes_read` is the size of returned `content` (after redaction).
  - `read` fails if redaction would expand output beyond `limits.max_read_bytes`.
  - `grep` truncates matched-line output to `limits.max_line_bytes` after redaction (`line_truncated=true`).
- Response path echo:
  - `read`/`write`/`patch`/`delete` responses include `requested_path` (normalized input) and `path` (normalized stored path).
- Scan diagnostics:
  - `glob`/`grep` responses include skip counters (e.g. secret denies, traversal skips) to make partial results explainable.

## HTTP service

By default the service requires an auth token configured in the policy file (`[auth]`), and each
token can be restricted to a workspace allowlist. For local development only, you can run with
`--unsafe-no-auth`.

Notes:

- Auth tokens:
  - Prefer storing only a hash in the policy: `sha256:<64 hex chars>`.
  - Or load a plaintext token from an environment variable: `auth.tokens[].token_env_var = "DB_VFS_TOKEN"`.
  - `--unsafe-no-auth` is restricted to loopback binds by default; use `--unsafe-no-auth-allow-non-loopback` only if you fully understand the risk.
- Policy loading:
  - `--trust-mode trusted|untrusted` controls whether risky policy features are allowed (default: `trusted`).
  - In `trusted` mode, the service interpolates `${VAR}` in policy files from the process environment.
  - In `untrusted` mode, the service refuses env interpolation, env-backed tokens, writes, full scans, audit paths, and `--unsafe-no-auth`.
- Request tracing uses `x-request-id`:
  - If the client sets it, the service echoes it back.
  - Otherwise the service generates one and returns it in the response headers.
- Optional JSONL audit log (policy `[audit]`):
  - If `audit.jsonl_path` is set, the service appends one JSON object per request (does not include file content or grep query text).
  - `audit.required` (default: `true`) controls whether audit initialization failures should fail service startup; set it to `false` to continue with audit disabled.
- Concurrency and pooling are controlled by policy `limits`:
  - `max_concurrency_io` (read/write/patch/delete)
  - `max_concurrency_scan` (glob/grep)
  - `max_db_connections` (SQLite/Postgres pool size)
  - `max_io_ms` (service timeout for read/write/patch/delete; also used for Postgres `statement_timeout`)
- Rate limiting is controlled by policy `limits`:
  - `max_requests_per_ip_per_sec`
  - `max_requests_burst_per_ip`
  - Note: the limiter uses the TCP peer address (it does not parse `x-forwarded-for`), so configure it appropriately when running behind a reverse proxy.
- Scan traversal skipping is controlled by policy `traversal`:
  - `traversal.skip_globs` (performance only; does not deny direct access)
- Timeout semantics:
  - Timeouts are best-effort wall-clock budgets at the service layer.
  - Timeouts include time spent waiting for the service concurrency semaphores; under sustained load a request may fail with `503 busy` rather than wait indefinitely.
  - For SQLite, the service attempts to interrupt in-flight queries on timeout; for Postgres, `statement_timeout` is configured.
  - A timed-out request returns early and releases its service concurrency slot; some DB work may still continue briefly in the background while cancellation/cleanup happens.
- Secrets are denied by default (e.g. `.env`, `.git/**`, `.ssh/**`, `.aws/**`, `.kube/**`, `.omne_agent_data/**`); adjust `policy.secrets` if needed.

### SQLite

Run:

```bash
cd db-vfs
cargo run -p db-vfs-service -- \
  --sqlite ./db-vfs.sqlite \
  --policy ./policy.example.toml \
  --listen 127.0.0.1:8080
```

Note: `policy.example.toml` disables `write`/`patch`/`delete` by default. For the smoke test below,
set `permissions.write = true` in your policy (or create a dev policy).

Security note (SQLite): file permissions depend on the process `umask`. For multi-user systems, set a restrictive `umask` (e.g. `077`) in your service manager / startup script.

### Postgres

Run (requires building with `postgres` enabled):

```bash
cd db-vfs
cargo run -p db-vfs-service --features postgres -- \
  --postgres "postgres://user:pass@localhost:5432/db_vfs" \
  --policy ./policy.example.toml \
  --listen 127.0.0.1:8080
```

Endpoints (JSON POST):

- `/v1/read`
- `/v1/write`
- `/v1/patch`
- `/v1/delete`
- `/v1/glob`
- `/v1/grep`

Error responses (JSON):

```json
{"code":"<stable_code>","message":"<human message>"}
```

Common `code` values:

- `unauthorized` (401): missing/invalid auth header or invalid token
- `forbidden` (403): workspace not allowed for token; or policy denied (`not_permitted`, `secret_path_denied`)
- `invalid_json` (400) / `unsupported_media_type` (415) / `payload_too_large` (413): request parsing/body limits
- `not_found` (404) / `conflict` (409)
- `timeout` (408) / `busy` (503) / `rate_limited` (429)
- `invalid_path` / `invalid_regex` / `patch` / `input_too_large` / `file_too_large` / `quota_exceeded` (mostly 400/413)

Minimal example:

```bash
curl -sS http://127.0.0.1:8080/v1/write \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","content":"hello","expected_version":null}'

curl -sS http://127.0.0.1:8080/v1/grep \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","query":"hello","regex":false,"glob":"docs/**/*.txt","path_prefix":null}'
```

## Development

Run gates (fmt/check/clippy/test):

```bash
./scripts/gate.sh
```

Enable git hooks:

```bash
./scripts/setup-githooks.sh
```

The hooks enforce Conventional Commits and require `CHANGELOG.md` updates. The Rust file size guard
can be overridden via `DB_VFS_MAX_RS_LINES=<N>`.


---
file: policy.example.toml
---

[permissions]
read = true
glob = true
grep = true
write = false
patch = false
delete = false
allow_full_scan = false

# Service auth (recommended).
#
# Requests must include:
#   Authorization: Bearer <token>
#
# Each token can be restricted to a workspace allowlist:
# - exact: "ws1"
# - prefix: "team1-*"
# - all: "*"
#
# Token values can be provided as plaintext (via env var) or stored as a SHA-256 hash:
# - Prefer storing only a SHA-256 hash in committed policies:
#     token = "sha256:<64 hex chars>"
# - Or load a plaintext token from an environment variable at runtime:
#     token_env_var = "DB_VFS_TOKEN"
#
# NOTE: don't commit real tokens.
[auth]
[[auth.tokens]]
token_env_var = "DB_VFS_TOKEN"
allowed_workspaces = ["*"]

# All limits have defaults; override as needed.
#
[limits]
# Recommended for production-ish deployments:
max_walk_ms = 2000

# Per-IP token-bucket rate limiting (set 0/0 to disable).
max_requests_per_ip_per_sec = 100
max_requests_burst_per_ip = 200
# Cap the number of distinct IPs tracked by the limiter.
max_rate_limit_ips = 65536

# Secrets are enabled by default in code, but can be customized here:
#
# [secrets]
# deny_globs = [".git/**", "**/.git/**", ".env", ".env.*", "**/.env", "**/.env.*", ".ssh/**", "**/.ssh/**", ".aws/**", "**/.aws/**", ".kube/**", "**/.kube/**", ".npmrc", "**/.npmrc", ".netrc", "**/.netrc", ".pypirc", "**/.pypirc", ".cargo/credentials", "**/.cargo/credentials", ".docker/config.json", "**/.docker/config.json", ".omne_agent_data/**", "**/.omne_agent_data/**"]
# redact_regexes = []
# replacement = "***REDACTED***"

# Scan traversal skip globs (performance only; does not deny direct access).
#
# [traversal]
# skip_globs = ["target/**", "**/target/**", "node_modules/**", "**/node_modules/**"]

# Optional JSONL audit log (service-only).
#
# When set, `db-vfs-service` appends one JSON object per request.
#
# [audit]
# jsonl_path = "./db-vfs-audit.jsonl"
# required = true # fail startup if audit log can't be opened (default: true)


---
file: SECURITY.md
---

# Security

## Threat model

`db-vfs` is a library + HTTP service for performing virtual filesystem operations against a
database-backed store with an explicit, caller-provided policy (`VfsPolicy`).

It enforces policy checks in-process. It is designed for *trusted* deployments (e.g. internal
services) where you still want strong, explicit guardrails.

## Not an OS sandbox

This project does **not** provide OS-level isolation. If you need strong isolation, run the service
inside an OS sandbox / container / VM and apply network controls.

## Auth & secrets

- The service requires `Authorization: Bearer <token>` by default.
- Prefer storing only `sha256:<64 hex>` token hashes in committed policy files.
- For plaintext tokens, use `auth.tokens[].token_env_var` so secrets live in the process environment.
- `--unsafe-no-auth` is restricted to loopback binds by default; using it on a public interface is
  dangerous.
- For production deployments, enforce “no-unsafe-flags” in your service manager / startup scripts
  (e.g. refuse `--unsafe-no-auth-allow-non-loopback`).

Secrets are mitigated via:

- Path deny rules (`policy.secrets.deny_globs`) to block direct access.
- Regex redaction (`policy.secrets.redact_regexes`) applied to `read`/`grep` output.

## Resource limits & DoS

Policy limits bound work and memory:

- Request sizes: `max_read_bytes`, `max_write_bytes`, `max_patch_bytes`.
- Scan bounds: `max_walk_entries`, `max_walk_files`, `max_walk_ms`, `max_results`.
- Service concurrency: `max_concurrency_io`, `max_concurrency_scan`, `max_db_connections`.
- Service timeouts: `max_io_ms` (plus Postgres `statement_timeout` when enabled).
- Per-IP rate limiting: `max_requests_per_ip_per_sec`, `max_requests_burst_per_ip`,
  `max_rate_limit_ips`.

These are best-effort safeguards, not a replacement for OS-level limits and network-level
mitigations (load balancers, WAF, reverse proxy rate limits, etc.).

SQLite note: database file permissions depend on the process `umask`; set a restrictive `umask`
in your service manager / startup script on multi-user systems.

## Timeout semantics

Service-layer timeouts return early to the client, but the underlying blocking DB operation may
continue briefly in the background. For SQLite, the service attempts to interrupt in-flight queries
on timeout; for Postgres, `statement_timeout` is configured. Treat timeouts as a *budgeting* and
*backpressure* mechanism, not a hard cancel.

## Path probing side-channels

If untrusted callers can control `path` inputs and observe detailed errors/timing, they may be able
to infer information about stored paths (existence, deny rules, etc.).

If this matters, reduce observable error detail, enforce rate limits, and run behind an API gateway.

## Reporting

If you discover a security issue, please open an issue with:

- Minimal reproduction
- Expected vs actual behavior
- Environment details (OS, Rust toolchain, DB backend)


---
file: CHANGELOG.md
---

# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added

- CI: add GitHub Actions workflows for gates/tests and docs deploy (mdBook → GitHub Pages).
- Dev: add `./scripts/setup-githooks.sh` helper to enable repo git hooks.
- `db-vfs-service`: optional Postgres backend via `--postgres` (build with `--features postgres`).
- Policy: `auth` section with bearer tokens + per-token workspace allowlist.
- Policy: `auth.tokens[].token_env_var` to load a plaintext token from an environment variable at runtime.
- Policy: `auth.tokens[].token = "sha256:<64 hex>"` for storing hashed tokens.
- Policy: `permissions.allow_full_scan` to gate `path_prefix = ""` scans for `glob`/`grep`.
- `db-vfs-service`: `--unsafe-no-auth` for local development.
- Policy: `limits.max_concurrency_io`, `limits.max_concurrency_scan`, and `limits.max_db_connections`.
- Policy: `limits.max_io_ms` for service IO timeouts.
- Policy: `limits.max_requests_per_ip_per_sec` and `limits.max_requests_burst_per_ip` for per-IP rate limiting.
- Policy: `limits.max_rate_limit_ips` to cap tracked IPs for rate limiting.
- Policy: `traversal.skip_globs` to skip paths during scan traversal (performance only).
- `db-vfs-service`: `x-request-id` header (propagated or generated) for request tracing.
- Policy: `audit.jsonl_path` for an optional JSONL audit log (service-only).
- Policy: `audit.required` to control whether audit init failures should fail service startup (default: fail).
- `db-vfs-service`: `--trust-mode trusted|untrusted` to restrict policy loading in untrusted environments.
- `db-vfs-service`: optional JSONL audit log when `audit.jsonl_path` is set.
- `db-vfs-service`: `${VAR}` env interpolation in policy files (trusted mode only).
- `db-vfs-core`: `glob_utils` helpers for glob normalization/validation.
- Docs: add `SECURITY.md` threat model and guidance.
- Dev: add `rust-toolchain.toml`, `rustfmt.toml`, `scripts/gate.sh`, and `githooks/` (Conventional Commits + changelog gate).
- Dev: pre-commit guard to block oversized Rust files (`DB_VFS_MAX_RS_LINES`).
- Docs: add mdBook docs under `docs/` and an LLM-friendly bundle (`llms.txt`, `docs/llms.txt`).
- Tests: add VFS regression coverage for grep/read redaction + limit semantics.
- Tests: add auth parsing/allowlist unit tests in `db-vfs-service`.
- Tests: add optional Postgres store integration test (requires `DB_VFS_TEST_POSTGRES_URL`).

### Changed

- Docs: include `llms.txt` in the built mdBook output (`docs/book/llms.txt`) for easy download when hosted.
- `db-vfs-service`: build with bundled SQLite (`rusqlite` feature `bundled`) for portability.
- `db-vfs-service`: run SQLite migrations with `busy_timeout` aligned to `limits.max_io_ms` (capped).
- Docs: recommend `./scripts/setup-githooks.sh` in development docs/README.
- Docs: clarify `path_prefix` scoping and `expected_version` CAS semantics.
- Docs: generate `llms.txt` bundles from `docs/src/SUMMARY.md` (stable ordering).
- Docs: `llms.txt` now includes `CHANGELOG.md` and starts with YAML front matter metadata.
- Dev: `./scripts/gate.sh` checks that `llms.txt` outputs are up to date.
- `db-vfs-service`: require `Authorization: Bearer <token>` by default (configured via policy).
- `db-vfs-service`: remove global VFS mutex; use per-request store with concurrency limiting.
- `db-vfs-service`: validate bearer token before parsing JSON request bodies.
- `db-vfs-service`: use r2d2 connection pooling for SQLite/Postgres stores.
- `db-vfs-service`: apply request timeouts for IO endpoints and set Postgres `statement_timeout`.
- `db-vfs-service`: apply a small service timeout headroom over `limits.max_io_ms` (to allow DB timeouts to fire first).
- `db-vfs-service`: add per-IP token-bucket rate limiting middleware.
- `db-vfs-service`: restrict `--unsafe-no-auth` to loopback binds by default.
- `db-vfs-service`: refactor server module into submodules to keep Rust files small.
- Policy: `auth.tokens[].token` now requires `sha256:<64 hex chars>` (use `token_env_var` for plaintext tokens).
- `db-vfs-core`: expand default `secrets.deny_globs` (e.g. `.omne_agent_data/**`, `.ssh/**`, `.aws/**`, `.kube/**`).
- `db-vfs-service`: bound the in-memory rate limiter map to avoid unbounded growth.
- Policy parsing: deny unknown fields (`serde(deny_unknown_fields)`).
- `policy.example.toml`: safer defaults (no write/patch/delete; auth enabled; full scan disabled).
- Store API: split file reads into `get_meta` + `get_content`.
- `db-vfs-core`: `path`/`path_prefix` now reject leading/trailing whitespace (no implicit trimming).
- `db-vfs-service`: log an auth configuration summary (counts) at startup without retaining tokens.

### Fixed

- Dev: remove unused variable warning when `db-vfs-service` is built without `postgres`.
- `db-vfs-service`: avoid panic on invalid/missing DB backend args.
- `db-vfs-service`: attempt to interrupt in-flight SQLite queries on timeout to reduce lingering background work.
- `db-vfs-service`: avoid blocking the async runtime when attempting SQLite timeout interrupts.
- `db-vfs-service`: include semaphore queueing time in request timeouts (avoid unbounded waits under load).
- `db-vfs-service`: ensure SQLite interrupts are still requested even if timeout races cancel-handle installation.
- Enforce size limits before fetching DB content to avoid memory DoS from oversized stored files.
- `glob`/`grep`: report `scan_limit_reason=Entries/Files` when truncated by DB prefix list limit.
- `db-vfs-service`: request body size limit and non-leaky 5xx error messages.
- `db-vfs-service`: hash bearer tokens once and compare in constant time; avoid retaining plaintext tokens.
- `db-vfs-core`: cap `path`/`path_prefix`, glob patterns, and grep queries to avoid oversized input allocations.
- Policy: validate `limits.max_io_ms` and cap request size limits to 256MB.
- `db-vfs-service`: map `input_too_large`, `file_too_large`, `secret_path_denied`, and `patch` errors to 4xx status codes.
- `db-vfs`: validate `workspace_id` and ensure `read` respects `limits.max_read_bytes` for line ranges.
- `db-vfs`: cap `read` retries when content cannot be loaded to avoid infinite loops.
- `glob`: report `scanned_files` separately from `scanned_entries` and respect `traversal.skip_globs`.
- `patch`: fetch existing content using `limits.max_read_bytes` (consistent with read limits).
- Lint: fix `clippy::large_enum_variant`.
- Docs: fix `Getting started` instructions to enable `permissions.write` when using `policy.example.toml`.
- `db-vfs-core`: validate `secrets.deny_globs`, `traversal.skip_globs`, and `secrets.replacement` sizes to avoid pathological policies.
- `db-vfs-service`: align SQLite `busy_timeout` with `limits.max_io_ms` (capped).
- Docs: document HTTP status codes and `429 rate_limited`.
- `db-vfs-service`: return JSON error bodies for invalid JSON / missing `content-type` (new codes: `invalid_json`, `unsupported_media_type`, `payload_too_large`).
- `glob`/`grep`: derive a safer `path_prefix` from glob patterns that end with `/` (avoid overscanning sibling prefixes).
- Docs: fix mdBook build (mdbook v0.5 config + SUMMARY nesting) and make `policy.example.toml` link work when building via `./scripts/docs.sh`.
- `db-vfs-service`: ensure request timeouts release the concurrency semaphore permit (avoid stuck permits under lingering blocking work).
- `grep`: reject empty queries and enforce `max_line_bytes` after redaction.
- `read`: enforce `max_read_bytes` after redaction and count `bytes_read` on returned content.
- `read`: return `conflict` (not `db`) when a file changes during retry-based content loading.
- `db-vfs`: `read`/`write`/`patch`/`delete` responses now include `requested_path` (normalized input).
- `glob`/`grep`: report additional skip counters (e.g. secret denies, traversal skips) to make partial results explainable.
- `db-vfs-service`: policy loader rejects non-regular files and avoids unbounded policy reads.
- `db-vfs-service`: `secret_path_denied` HTTP errors no longer include the denied path in the message.
- Policy: reject `audit.jsonl_path` values with leading/trailing whitespace or control characters.
- CI: docs workflow no longer fails when GitHub Pages is not enabled (skips deploy).

## [0.1.0] - 2026-01-31

### Added

- `db-vfs-core`: Policy + Secrets + Limits, error codes, path normalization, deny+redaction helpers.
- `db-vfs`: SQLite (default) + Postgres (feature) stores and VFS ops: `read/write/patch/delete/glob/grep`.
- `db-vfs-service`: HTTP JSON API for the VFS (SQLite).
- Schema migrations for SQLite/Postgres (`files` table with `(workspace_id, path)` primary key + `updated_at_ms` index).
- Tests:
  - SQLite VFS semantic tests (CAS conflicts, deny globs, grep/glob scoping).
  - HTTP smoke test for `write` + `read`.


---
file: docs/src/SUMMARY.md
---

# Summary

* [Introduction](index.md)
* [Getting started](getting-started.md)
* [Concepts](concepts.md)
* [Guides](guides.md)
  * [Policy](policy.md)
  * [HTTP API](http-api.md)
  * [Storage backends](storage.md)
  * [Security](security.md)
  * [Observability](observability.md)
  * [Troubleshooting](troubleshooting.md)
  * [Development](development.md)
  * [`llms.txt`](llms.md)


---
file: docs/src/index.md
title: Introduction
---

# db-vfs

`db-vfs` is a DB-backed “virtual filesystem” (VFS) intended for server / high-concurrency workloads.

It provides tool-like operations with explicit safety policy enforcement:

- `read` (optional line ranges)
- `glob`
- `grep`
- `write`
- `patch` (unified diff)
- `delete`

This repo contains:

- `db-vfs` (crate): core VFS operations backed by a `Store` trait.
- `db-vfs-service` (crate): an HTTP JSON service (Axum) with auth, request limits, and concurrency control.

Non-goals:

- Full git-repo tooling (checkout/build, etc).
- Large binary file storage.
- Unbounded traversal/search (scans are scoped and budgeted).

## Where to start

- New users: [`Getting started`](getting-started.md)
- Understanding semantics: [`Concepts`](concepts.md)
- Configuration: [`Policy`](policy.md) and [`policy.example.toml`](policy.example.toml)
- Integrating over HTTP: [`HTTP API`](http-api.md)
- LLM/RAG ingestion: [`llms.txt`](llms.md)


---
file: docs/src/getting-started.md
title: Getting started
---

# Getting started

## Prerequisites

- Rust toolchain (see `rust-toolchain.toml`)

## Run the service (SQLite)

Create a policy file (start from `policy.example.toml`) and set a bearer token at runtime:

```bash
export DB_VFS_TOKEN='dev-token-change-me'
```

For local development, enable writes in your policy:

```toml
# In your policy's `[permissions]` section (e.g. `policy.example.toml`)
[permissions]
write = true
```

Run:

```bash
cargo run -p db-vfs-service -- \
  --sqlite ./db-vfs.sqlite \
  --policy ./policy.example.toml \
  --listen 127.0.0.1:8080
```

## Smoke test

Write a file:

```bash
curl -sS http://127.0.0.1:8080/v1/write \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","content":"hello","expected_version":null}'
```

Read it back:

```bash
curl -sS http://127.0.0.1:8080/v1/read \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","start_line":null,"end_line":null}'
```


---
file: docs/src/concepts.md
title: Concepts
---

# Concepts

## Namespace: `workspace_id`

`workspace_id` is the namespace boundary. All operations are scoped to:

- `workspace_id`
- a root-relative `path` or `path_prefix`

## Root-relative paths

All `path` / `path_prefix` values are root-relative:

- Must not start with `/`
- Must not contain `..`

`path_prefix` may be empty (`""`) to mean “the whole workspace” **only if**
`policy.permissions.allow_full_scan = true`.

## Safety policy

The policy is validated on load and governs:

- Which operations are permitted (`permissions`)
- How much work each request can do (`limits`)
- Which paths are denied or redacted (`secrets`)
- Which paths are skipped during scans only (`traversal`)
- Service auth tokens and workspace allowlists (`auth`)

## Concurrency and CAS

Writes are guarded by optimistic concurrency using a monotonically increasing `version`:

- `read` returns the current `version`
- `write(expected_version = null)` is **create-only**
- `write(expected_version = v)` updates iff the current version is `v`
- `patch` requires `expected_version`
- `delete(expected_version = v)` enforces CAS; `delete(expected_version = null)` is unconditional

## Scan scoping

To avoid unbounded traversal, scan operations are scoped:

- `grep` requires an explicit `path_prefix` unless a safe literal prefix can be derived from `glob`
- `glob` similarly requires `path_prefix` for broad patterns without a safe literal prefix

## Error codes

Library errors carry stable `code`s (e.g. `invalid_path`, `not_permitted`, `conflict`, `timeout`).
The HTTP service maps these to HTTP status codes and returns a JSON error body.


---
file: docs/src/guides.md
title: Guides
---

# Guides

This section collects operational docs for running `db-vfs` safely:

- Policy configuration: [`Policy`](policy.md)
- HTTP endpoints and error mapping: [`HTTP API`](http-api.md)
- Storage backends and migrations: [`Storage backends`](storage.md)
- Threat model and hardening notes: [`Security`](security.md)
- Logging and request IDs: [`Observability`](observability.md)
- Common errors: [`Troubleshooting`](troubleshooting.md)
- Contributing and local dev workflows: [`Development`](development.md)
- LLM bundle generation: [`llms.txt`](llms.md)



---
file: docs/src/policy.md
title: Policy
---

# Policy

The service loads a policy file (`.toml` or `.json`) into `db_vfs_core::policy::VfsPolicy`.

Start from `policy.example.toml` (also linked as [`policy.example.toml`](policy.example.toml) in the built docs).

## Sections

### `[permissions]`

Toggles operations on/off:

- `read`, `glob`, `grep`, `write`, `patch`, `delete`
- `allow_full_scan`: allow `path_prefix=""` for `glob`/`grep`

### `[auth]` / `[[auth.tokens]]`

The HTTP service requires:

```
Authorization: Bearer <token>
```

Each token is restricted to a workspace allowlist (`allowed_workspaces`):

- exact: `"ws1"`
- prefix: `"team1-*"`
- all: `"*"`

Tokens can be provided as:

- `token = "sha256:<64 hex chars>"` (recommended for committed policies)
- `token_env_var = "DB_VFS_TOKEN"` (load plaintext token at runtime)

### `[limits]`

Budgets to control CPU/memory/DB load, including:

- request sizes: `max_read_bytes`, `max_write_bytes`, `max_patch_bytes`
- scan budgets: `max_walk_entries`, `max_walk_files`, `max_walk_ms`, `max_results`
- service: `max_io_ms`, `max_concurrency_io`, `max_concurrency_scan`, `max_db_connections`
- rate limiting: `max_requests_per_ip_per_sec`, `max_requests_burst_per_ip`, `max_rate_limit_ips`

### `[secrets]`

Controls deny rules and text redaction:

- `deny_globs`: deny direct access to matching paths
- `redact_regexes`: applied to returned text
- `replacement`: string used to replace redacted matches

### `[traversal]`

Scan-only skipping rules:

- `skip_globs`: skipped during `glob`/`grep` traversal (performance only; does not deny direct reads)

### `[audit]`

Service-only observability:

- `jsonl_path`: optional JSONL log path; when set, `db-vfs-service` appends one JSON object per request.
- `required`: whether audit initialization failures should fail service startup (default: `true`).


---
file: docs/src/http-api.md
title: HTTP API
---

# HTTP API

The service exposes JSON POST endpoints:

- `/v1/read`
- `/v1/write`
- `/v1/patch`
- `/v1/delete`
- `/v1/glob`
- `/v1/grep`

All requests require:

- `content-type: application/json`
- `authorization: Bearer <token>` (unless started with `--unsafe-no-auth`)

Notes on success responses:

- `read`/`write`/`patch`/`delete` include `requested_path` (normalized input) and `path` (normalized stored path).
- `glob`/`grep` include scan counters and `skipped_*` diagnostics to make partial results explainable.

## Errors

Errors are returned as JSON with an HTTP status code:

```json
{ "code": "invalid_path", "message": "..." }
```

5xx errors use a non-leaky `"internal error"` message.

### Status codes

- `400`: `invalid_path`, `invalid_regex`, `invalid_json`, `patch`
- `401`: `unauthorized` (missing/invalid `Authorization`)
- `403`: `forbidden`, `not_permitted`, `secret_path_denied`
- `404`: `not_found`
- `408`: `timeout`
- `409`: `conflict`
- `413`: `payload_too_large`, `input_too_large`, `file_too_large`, `quota_exceeded`
- `415`: `unsupported_media_type` (missing/invalid `content-type`)
- `429`: `rate_limited`
- `503`: `busy`

## Tracing

- The service accepts and returns `x-request-id`.
- If missing, it generates one and includes it on the response.


---
file: docs/src/storage.md
title: Storage backends
---

# Storage backends

## SQLite

- Intended for dev/test and single-node deployments.
- Uses `r2d2_sqlite` for connection pooling.
- The service attempts to interrupt in-flight SQLite queries on timeout (best-effort).

## Postgres

- Intended for production deployments (build with `--features postgres`).
- Uses `r2d2_postgres` for connection pooling.
- The service configures Postgres `statement_timeout` based on policy `limits.max_io_ms`.

## Migrations

Migrations live under `migrations/` and are applied on startup:

- `migrations/sqlite/`
- `migrations/postgres/`


---
file: docs/src/security.md
title: Security
---

# Security

See `SECURITY.md` for the threat model and guidance.

Key points:

- Root-relative path normalization rejects `/`-absolute paths and `..` segments.
- Secret deny rules apply to direct access; redaction applies to returned text.
- `glob`/`grep` require scoping (`path_prefix`) unless explicitly allowed.
- Auth is required by default; `--unsafe-no-auth` is intended for local development only.
- If the policy/config is not fully trusted, run the service with `--trust-mode untrusted` to disable risky features (env interpolation, env-backed tokens, writes, full scans, audit paths, and `--unsafe-no-auth`).
- The rate limiter uses the TCP peer IP and does not parse `x-forwarded-for`.


---
file: docs/src/observability.md
title: Observability
---

# Observability

## `x-request-id`

The service:

- Echoes `x-request-id` if provided by the client.
- Otherwise generates one and adds it to the response headers.

## Logging

The service uses `tracing`; configure via `RUST_LOG`, for example:

```bash
RUST_LOG=db_vfs_service=info cargo run -p db-vfs-service -- --sqlite ./db.sqlite --policy ./policy.example.toml
```

## JSONL audit log (optional)

If `policy.audit.jsonl_path` is set, the service appends one JSON object per request (JSONL / ndjson).

Notes:

- Records include `request_id`, `peer_ip`, `op`, `workspace_id`, `status`, and scan diagnostics.
- Records do not include file content or grep query text (grep logs only query length + regex flag).
- `policy.audit.required` controls startup behavior if the audit log cannot be initialized (default: fail startup).


---
file: docs/src/troubleshooting.md
title: Troubleshooting
---

# Troubleshooting

## `401 unauthorized`

- Missing or invalid `Authorization` header.
- Token does not match any configured auth rule.

## `403 forbidden`

- Workspace is not allowed for the current token.
- Operation is disabled by policy.

## `408 timeout`

- Request exceeded the configured wall-clock timeout budget.
- For SQLite, the service attempts to interrupt in-flight queries (best-effort).

## `413 payload too large`

- Request exceeded `limits.max_read_bytes` / `max_write_bytes` / `max_patch_bytes`.

## `415 unsupported media type`

- Missing or invalid `content-type`; the API expects `application/json`.

## `429 too many requests`

- Per-IP rate limit exceeded (`limits.max_requests_per_ip_per_sec` / `max_requests_burst_per_ip`).

## `503 busy`

- The service is at its configured concurrency limit.


---
file: docs/src/development.md
title: Development
---

# Development

## Gates

Run format/check/clippy/test:

```bash
./scripts/gate.sh
```

## Git hooks

Enable local hooks:

```bash
./scripts/setup-githooks.sh
```

The hooks enforce:

- Conventional Commits messages
- `CHANGELOG.md` updates in every commit
- a max Rust file size guard (`DB_VFS_MAX_RS_LINES`, default 1000)

## Docs

Build the mdBook (requires `mdbook`):

```bash
./scripts/docs.sh
```

Regenerate `llms.txt`:

```bash
./scripts/llms.sh
```

Verify `llms.txt` is up to date:

```bash
./scripts/llms.sh --check
```


---
file: docs/src/llms.md
title: `llms.txt`
---

# `llms.txt`

Inspired by the AI SDK docs’ `llms.txt`, this repo includes a single-file documentation bundle for
LLM/RAG ingestion:

- `llms.txt` (repo root)
- `docs/llms.txt` (same content, colocated with docs)

Both are Markdown stored in a `.txt` file (with YAML front matter) so they can be copied/pasted into
LLM tools easily.

## Download

If you build the docs with `./scripts/docs.sh`, the rendered book output includes:

- [`llms.txt`](llms.txt)

## Regenerate

After documentation changes:

```bash
./scripts/llms.sh
```

Verify it is up to date:

```bash
./scripts/llms.sh --check
```

## Suggested prompt

Paste `llms.txt` into your LLM tool as context, then ask questions like:

> Use the provided `llms.txt` documentation to answer my questions about `db-vfs`.
> If the answer is not in the docs, say so explicitly.

