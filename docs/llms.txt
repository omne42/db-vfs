---
title: db-vfs docs bundle
description: DB-backed virtual filesystem with explicit Policy + Secrets + Limits, plus an HTTP service.
tags: [rust, sqlite, postgres, vfs, security, policy, http]
generated_at_utc: stable
source_commit: workspace
generator_version: scripts/llms.sh@v3
bundle_type: stable-with-recent-history
---

# db-vfs — LLM documentation bundle

This bundle is generated from repository docs for RAG/LLM ingestion.

Normative priority for behavior conflicts:

1. Policy
2. HTTP API
3. Concepts
4. Security
5. Other guides
6. Changelog (history reference only)

Unreleased changelog items do not necessarily represent current released behavior.

Update with:

  ./scripts/llms.sh

---
file: README.md
title: "Project README"
section_id: "readme-md"
---

# db-vfs

DB-backed virtual filesystem (DB-VFS) for service workloads.

## What it provides

- Safety-first policy model: **Permissions + Limits + Secrets + Traversal + Auth**.
- Tool-like operations: `read`, `write`, `patch`, `delete`, `glob`, `grep`.
- Backends: SQLite (default/dev) and Postgres (`--features postgres`).

## Quickstart (5 min)

1. Create a local policy and token:

```bash
cp policy.example.toml policy.local.toml
export DB_VFS_TOKEN='dev-token-change-me'
```

2. Enable local writes in `policy.local.toml`:

```toml
[permissions]
write = true
```

3. Start SQLite service:

```bash
cargo run -p db-vfs-service -- \
  --sqlite ./db-vfs.sqlite \
  --policy ./policy.local.toml \
  --listen 127.0.0.1:8080
```

4. Verify write/read:

```bash
curl -sS http://127.0.0.1:8080/v1/write \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","content":"hello","expected_version":null}'

curl -sS http://127.0.0.1:8080/v1/read \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","start_line":null,"end_line":null}'
```

## API field reference (minimal)

All endpoints are JSON `POST` and require:

- `content-type: application/json`
- `authorization: Bearer <token>` (unless `--unsafe-no-auth`)

| Endpoint | Request fields | Key response fields | Typical errors |
| --- | --- | --- | --- |
| `/v1/read` | `workspace_id`, `path`, `start_line?`, `end_line?` | `requested_path`, `path`, `content`, `bytes_read`, `version` | `unauthorized`, `invalid_path`, `not_found` |
| `/v1/write` | `workspace_id`, `path`, `content`, `expected_version?` | `requested_path`, `path`, `bytes_written`, `created`, `version` | `conflict`, `file_too_large` |
| `/v1/patch` | `workspace_id`, `path`, `patch`, `expected_version` | `requested_path`, `path`, `bytes_written`, `version` | `patch`, `conflict`, `not_found` |
| `/v1/delete` | `workspace_id`, `path`, `expected_version?` | `requested_path`, `path`, `deleted` | `conflict`, `not_found` |
| `/v1/glob` | `workspace_id`, `pattern`, `path_prefix?` | `matches`, `truncated`, scan counters | `not_permitted`, `timeout` |
| `/v1/grep` | `workspace_id`, `query`, `regex`, `glob?`, `path_prefix?` | `matches[]`, `truncated`, scan counters | `invalid_regex`, `not_permitted`, `timeout` |

Error body:

```json
{"code":"<stable_code>","message":"<human message>"}
```

## Security Baseline

- Keep auth enabled; avoid `--unsafe-no-auth` outside local isolated dev.
- Prefer `sha256:<64 hex>` tokens or env-backed runtime tokens.
- Scope tokens with `allowed_workspaces` (avoid broad `*` in production).
- Use TLS/HTTPS end-to-end for bearer token transport.
- Enable audit log with `audit.required = true`.

## Performance Limits

Tune policy `limits` for your workload:

- request bytes: `max_read_bytes`, `max_write_bytes`, `max_patch_bytes`
- scan bounds: `max_results`, `max_walk_files`, `max_walk_entries`, `max_walk_ms`, `max_line_bytes`
- concurrency: `max_concurrency_io`, `max_concurrency_scan`, `max_db_connections`
- timeout/rate: `max_io_ms`, `max_requests_per_ip_per_sec`, `max_requests_burst_per_ip`

## Observability / Audit

- `x-request-id` is accepted/echoed; invalid/missing IDs are replaced by service-generated IDs.
- Optional JSONL audit via `audit.jsonl_path`.
- Early rejects (unauthorized/invalid JSON/rate-limited) are audited with `workspace_id="<unknown>"`.
- Service logs use `tracing`; configure via `RUST_LOG`.

## Troubleshooting matrix

| HTTP | Common causes | First checks |
| --- | --- | --- |
| `401` | missing/invalid token | `Authorization`, token hash/env var |
| `403` | workspace/policy denied | `allowed_workspaces`, `permissions.*`, `secrets.deny_globs` |
| `409` | stale CAS version | re-read latest version before retry |
| `408` | timeout budget exceeded | `limits.max_io_ms`, DB latency, queueing |
| `503` | concurrency saturation | `max_concurrency_*`, `max_db_connections` |

## More docs

- Human docs (`mdBook`): `docs/` (`./scripts/docs.sh`)
- LLM bundle: `llms.txt` and `docs/llms.txt` (`./scripts/llms.sh`)


---
file: policy.example.toml
title: "Policy Example"
section_id: "policy-example-toml"
---

[permissions]
read = true
glob = true
grep = true
write = false
patch = false
delete = false
allow_full_scan = false

[auth]
[[auth.tokens]]
token_env_var = "DB_VFS_TOKEN"
allowed_workspaces = ["team-a-*"]

[limits]
max_walk_ms = 2000
max_requests_per_ip_per_sec = 30
max_requests_burst_per_ip = 60
max_rate_limit_ips = 8192

[secrets]
deny_globs = [
  ".env",
  ".env.*",
  "**/.env",
  "**/.env.*",
  ".git/**",
  "**/.git/**",
  ".ssh/**",
  "**/.ssh/**",
]
redact_regexes = [
  "(?i)api[_-]?key\\s*[:=]\\s*[A-Za-z0-9._-]{16,}",
]
replacement = "***REDACTED***"

[traversal]
skip_globs = [
  "target/**",
  "**/target/**",
  "node_modules/**",
  "**/node_modules/**",
]

[audit]
jsonl_path = "./db-vfs-audit.jsonl"
required = true
flush_every_events = 32
flush_max_interval_ms = 250


---
file: SECURITY.md
title: "Security Policy"
section_id: "security-md"
---

# Security Policy

## Private vulnerability reporting

Do **not** disclose unpatched vulnerabilities in public issues.

Preferred channel:

- GitHub Private Vulnerability Reporting / Security Advisory (if enabled for this repository).

If private advisory is unavailable, contact maintainers privately first and avoid posting exploit
details publicly.

## Response process (target SLA)

- Acknowledge report: within **72 hours**.
- Initial triage + severity assignment: within **7 days**.
- Fix + coordinated disclosure target:
  - critical/high: as soon as possible (typically <= 30 days)
  - medium/low: next scheduled patch cycle.

Actual timelines depend on exploitability and patch validation.

## Supported versions

| Version line | Status | Security fixes |
| --- | --- | --- |
| `Unreleased` / `main` | active | yes |
| latest stable (`0.1.x`) | active | yes |
| older than latest stable | EOL | no guarantee |

## Security baseline requirements

- Use HTTPS/TLS for all bearer-token transport.
- Keep auth enabled in production; avoid `--unsafe-no-auth`.
- Use high-entropy tokens (random, >= 32 bytes recommended) and rotate regularly.
- Scope tokens by `allowed_workspaces` (avoid global wildcard in production).
- Enable per-IP rate limiting and audit logging.

## Threat model notes

`db-vfs` is an application-layer guardrail system, not an OS sandbox.

- It validates paths/policies and enforces operation budgets.
- It mitigates secrets exposure via deny-globs and redaction.
- It does **not** replace container sandboxing, host hardening, or network controls.

For stronger isolation, deploy inside hardened containers/VMs and enforce edge gateway controls.


---
file: CHANGELOG.md
title: "Changelog (recent summary)"
section_id: "changelog-md-summary"
---

> Note: this is a recent summary only; full history remains in `CHANGELOG.md`.

# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Security

- service/auth: enable bearer auth by default, tighten workspace allowlist matching, and compare token hashes in constant time.
- service/headers: cap oversized `Authorization` headers and strictly validate/sanitize incoming `x-request-id`.
- service/policy: harden untrusted policy loading by rejecting env-token interpolation and non-regular policy files.
- core/path-policy: tighten workspace/path validation (control chars, wildcard constraints, oversized inputs).
- migrations: add DB-level integrity checks for version/timestamp/path/content-size consistency.

### Changed

- service/runtime: move to per-request stores with pooled SQLite/Postgres connections, bounded concurrency, and timeout headroom.
- service/api: split JSON parse/schema rejections into stable error codes and standardize 4xx mappings for client-visible validation failures.
- vfs/api: `read`/`write`/`patch`/`delete` responses now include `requested_path` for normalized input traceability.
- docs/policy example: align defaults and guidance with safer production posture and explicit scope/limit semantics.
- docs/api: expand HTTP contract, observability, troubleshooting, and deployment guidance for operations and integration.

### Fixed

- store/vfs: reject version overflow and enforce record/meta invariants to avoid silent persistence inconsistencies.
- read/grep/glob/patch: tighten limit enforcement (size, redaction, scan truncation) and improve conflict/diagnostic behavior.
- audit: improve lock-path derivation, batch flush behavior, and failure handling for early rejection paths.
- service/middleware: avoid creating rate-limit buckets for missing peer IP and ensure fallback request IDs for middleware-generated audit events.

### Internal

- ci/scripts/hooks: pin actions, align multi-platform gates, add workflow timeouts, and strengthen local commit policy checks.
- tooling/docs: enforce llms bundle freshness and mdBook workflow consistency in local/CI gates.
- tests: add regression coverage for request-id sanitization, auth-before-json parsing, no-IP rate-limit semantics, store invariants, and migration constraints.

## [0.1.0] - 2026-01-31

### Added

- `db-vfs-core`: Policy + Secrets + Limits, error codes, path normalization, deny+redaction helpers.
- `db-vfs`: SQLite (default) + Postgres (feature) stores and VFS ops: `read/write/patch/delete/glob/grep`.
- `db-vfs-service`: HTTP JSON API for the VFS (SQLite).
- Schema migrations for SQLite/Postgres (`files` table with `(workspace_id, path)` primary key + `updated_at_ms` index).
- Tests:
  - SQLite VFS semantic tests (CAS conflicts, deny globs, grep/glob scoping).
  - HTTP smoke test for `write` + `read`.


---
file: docs/src/SUMMARY.md
title: "Docs Summary"
section_id: "docs-src-summary-md"
---

# Summary

* [Introduction](index.md)
* [Getting Started](getting-started.md)
* [Concepts](concepts.md)
* [Guides](guides.md)
  * [Policy](policy.md)
  * [HTTP API](http-api.md)
  * [Storage Backends](storage.md)
  * [Security](security.md)
  * [Observability](observability.md)
  * [Troubleshooting](troubleshooting.md)
  * [Development](development.md)
  * [LLM Context (llms.txt)](llms.md)


---
file: docs/src/index.md
title: "Introduction"
section_id: "docs-src-index-md"
---

# db-vfs

`db-vfs` is a DB-backed virtual filesystem for service workloads.

It provides six operations:

- `read`: read a file (optionally by line range).
- `write`: create or CAS-update a file.
- `patch`: CAS-apply unified diff to a file.
- `delete`: delete with optional CAS version.
- `glob`: list paths by glob pattern.
- `grep`: search text under scoped traversal.

## Safety model

`db-vfs` enforces a policy-first model:

- **Permissions** decide which operations are allowed.
- **Limits** bound CPU/memory/DB work.
- **Secrets** deny sensitive paths and redact output.
- **Traversal** skips noisy paths for scan performance.
- **Auth** binds tokens to workspace allowlists.

Scan operations are **scoped and budgeted**: callers must provide `path_prefix` (or a safe literal
prefix must be derivable from `glob`), and traversal is constrained by `limits.*` budgets.

## High-concurrency expectations

High concurrency assumes all of the following are configured correctly:

- `limits.max_concurrency_io`, `limits.max_concurrency_scan`
- `limits.max_db_connections`, `limits.max_io_ms`
- per-IP rate limiting (`limits.max_requests_per_ip_per_sec`, `max_requests_burst_per_ip`, `max_rate_limit_ips`)

## Start here

- First deployment: read [`Policy`](policy.md) → [`Security`](security.md) → [`Storage Backends`](storage.md)
- API integration: read [`Concepts`](concepts.md) → [`HTTP API`](http-api.md)
- Production operations: read [`Observability`](observability.md) → [`Troubleshooting`](troubleshooting.md)


---
file: docs/src/getting-started.md
title: "Getting Started"
section_id: "docs-src-getting-started-md"
---

# Getting Started

## Prerequisites

Run from repository root (`db-vfs/`).

```bash
rustc --version
cargo --version
```

Expected: Rust/Cargo are installed and versions are available.

## 5-minute local run (SQLite)

1. Copy a local policy file (do not edit the example in place):

```bash
cp policy.example.toml policy.local.toml
```

2. Set a development token:

```bash
export DB_VFS_TOKEN='dev-token-change-me'
```

3. Enable local writes in `policy.local.toml`:

```toml
[permissions]
write = true
```

4. Start service:

```bash
cargo run -p db-vfs-service -- \
  --sqlite ./db-vfs.sqlite \
  --policy ./policy.local.toml \
  --listen 127.0.0.1:8080
```

## Smoke test

Write:

```bash
curl -sS http://127.0.0.1:8080/v1/write \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","content":"hello","expected_version":null}'
```

Expected response fragment:

```json
{"path":"docs/a.txt","created":true,"version":1}
```

Read:

```bash
curl -sS http://127.0.0.1:8080/v1/read \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","start_line":null,"end_line":null}'
```

Expected response fragment:

```json
{"path":"docs/a.txt","content":"hello","version":1}
```

## Common startup mistakes

- `401 unauthorized`: token missing/wrong; check `Authorization` and `DB_VFS_TOKEN`.
- `403 not_permitted`: `permissions.write = false`; enable write in policy.
- `415 unsupported_media_type`: missing `content-type: application/json`.


---
file: docs/src/concepts.md
title: "Concepts"
section_id: "docs-src-concepts-md"
---

# Concepts

## Core rules

- `workspace_id` **MUST** be valid and non-empty.
- `path` and `path_prefix` **MUST** be root-relative (no leading `/`, no `..`, no control chars).
- `path_prefix = ""` **MUST NOT** be used unless `permissions.allow_full_scan = true`.
- `read/write/patch/delete` **MUST** pass secret deny checks for target path.
- `glob/grep` **MUST** be scoped by `path_prefix` unless a safe literal prefix is derivable.

## Safe literal prefix

A safe literal prefix is a non-wildcard, root-relative directory prefix extracted from `glob`.

Examples:

- `docs/**/*.md` -> safe prefix `docs/`.
- `docs/*` -> safe prefix `docs/`.
- `**/*.md` -> no safe prefix (caller must provide `path_prefix`).
- `*/foo/*.md` -> no safe prefix.

## Operation semantics matrix

| Operation | Target exists | expected_version | Result |
| --- | --- | --- | --- |
| `write` | no | `null` | create (version=1) |
| `write` | yes | `null` | `conflict` |
| `write` | yes | `v` matches | update (version+1) |
| `write` | yes | `v` mismatches | `conflict` |
| `patch` | yes | `v` matches | patched (version+1) |
| `patch` | yes/no | `v` mismatches or missing | `conflict` / `not_found` |
| `delete` | yes | `null` | deleted |
| `delete` | yes | `v` matches | deleted |
| `delete` | yes | `v` mismatches | `conflict` |
| `delete` | no | any | `not_found` |

## Path normalization

Canonicalization is deterministic:

1. validate root-relative constraints;
2. normalize separators;
3. reject invalid forms (`..`, control chars, invalid workspace id);
4. return canonical `requested_path` and normalized stored `path`.

## Error contract

| `code` | Typical HTTP | Retry? | Client action |
| --- | --- | --- | --- |
| `unauthorized` | 401 | no | fix token/header |
| `not_permitted` / `secret_path_denied` | 403 | no | fix policy/path |
| `conflict` | 409 | conditional | re-read latest version and retry |
| `timeout` | 408 | yes | backoff + retry |
| `busy` / `rate_limited` | 503 / 429 | yes | backoff + retry with limits |
| `invalid_*` / `patch` | 400 | no | fix request payload |


---
file: docs/src/guides.md
title: "Guides"
section_id: "docs-src-guides-md"
---

# Guides

Audience and first path:

- Operators: start with Policy -> Security -> Storage Backends.
- Integrators: start with Concepts -> HTTP API.
- Maintainers: start with Development -> Observability.

## Before launch

- [`Policy`](policy.md): configuration defaults, limits, auth patterns.
- [`Security`](security.md): hardening checklist and trust boundaries.
- [`Storage Backends`](storage.md): backend behavior, timeouts, migrations.

## Runtime operations

- [`HTTP API`](http-api.md): request/response contracts and retry guidance.
- [`Observability`](observability.md): request IDs, logging, audit schema.

## Incident handling

- [`Troubleshooting`](troubleshooting.md): error matrix and remediation steps.
- [`Development`](development.md): validation scripts and CI parity.
- [`LLM Context (llms.txt)`](llms.md): generated context bundle and regeneration flow.

Last updated: 2026-02-06
Owner: db-vfs maintainers


---
file: docs/src/policy.md
title: "Policy"
section_id: "docs-src-policy-md"
---

# Policy

Service policy is loaded as `db_vfs_core::policy::VfsPolicy` (`.toml` or `.json`).

Start from [`policy.example.toml`](policy.example.toml).

## Default highlights

| Section | Key | Default |
| --- | --- | --- |
| `permissions` | `read/glob/grep` | `true` |
| `permissions` | `write/patch/delete` | `false` |
| `permissions` | `allow_full_scan` | `false` |
| `audit` | `required` | `true` |
| `limits` | `max_walk_ms` | `Some(2000)` |

## `allowed_workspaces` matching

Supported patterns:

- `*`: allow all workspaces.
- exact match, e.g. `ws-prod`.
- trailing wildcard prefix, e.g. `team-a-*`.

Not supported:

- multiple `*` (`foo*bar*`)
- middle wildcard (`a*b`)
- malformed patterns rejected by policy validation.

## Token hash generation

Input is raw token bytes exactly as sent by client; no extra trimming beyond your shell quoting.

```bash
printf '%s' 'dev-token-change-me' | sha256sum
# then use: token = "sha256:<hex>"
```

## Limits reference

Critical bounded fields include:

- request bytes: `max_read_bytes`, `max_write_bytes`, `max_patch_bytes`
- scan bounds: `max_results`, `max_walk_files`, `max_walk_entries`, `max_walk_ms`, `max_line_bytes`
- service runtime: `max_io_ms`, concurrency and DB pool limits
- rate limit: `max_requests_per_ip_per_sec`, `max_requests_burst_per_ip`, `max_rate_limit_ips`

## Audit behavior matrix

| `audit.jsonl_path` | `audit.required` | Startup behavior |
| --- | --- | --- |
| unset | `true/false` | audit disabled |
| set + writable | `true/false` | audit enabled |
| set + open fails | `true` | startup fails |
| set + open fails | `false` | startup continues, audit disabled |

`flush_every_events` and `flush_max_interval_ms` are valid only when `jsonl_path` is set.


---
file: docs/src/http-api.md
title: "HTTP API"
section_id: "docs-src-http-api-md"
---

# HTTP API

All endpoints are `POST` JSON.

## Request prerequisites

- Header `content-type: application/json`
- Header `authorization: Bearer <token>` (unless service runs with `--unsafe-no-auth`)

## Endpoint contracts

### `/v1/read`

Request fields:

| Field | Type | Required | Notes |
| --- | --- | --- | --- |
| `workspace_id` | string | yes | namespace |
| `path` | string | yes | root-relative path |
| `start_line` | u64|null | no | must pair with `end_line` |
| `end_line` | u64|null | no | must pair with `start_line` |

Response fields: `requested_path`, `path`, `bytes_read`, `content`, `truncated`, `start_line`, `end_line`, `version`.

### `/v1/write`

Request fields: `workspace_id`, `path`, `content`, `expected_version` (`u64|null`).

Response fields: `requested_path`, `path`, `bytes_written`, `created`, `version`.

### `/v1/patch`

Request fields: `workspace_id`, `path`, `patch`, `expected_version` (`u64`, required).

Response fields: `requested_path`, `path`, `bytes_written`, `version`.

### `/v1/delete`

Request fields: `workspace_id`, `path`, `expected_version` (`u64|null`).

Response fields: `requested_path`, `path`, `deleted`.

### `/v1/glob`

Request fields: `workspace_id`, `pattern`, `path_prefix` (`string|null`).

Response fields: `matches`, `truncated`, `scanned_files`, `scanned_entries`, `scan_limit_reached`, `scan_limit_reason`, `elapsed_ms`, and skip counters.

### `/v1/grep`

Request fields: `workspace_id`, `query`, `regex` (`bool`), `glob` (`string|null`), `path_prefix` (`string|null`).

Response fields: `matches[] { path, line, text, line_truncated }`, plus scan diagnostics (same shape as `glob`).

## Path normalization rules

- must be root-relative;
- no leading `/`, no `..`, no control chars, no leading/trailing whitespace;
- normalized path is echoed in response fields.

## Errors

Error body:

```json
{ "code": "<stable_code>", "message": "<human readable>" }
```

Common codes:

- `invalid_json_syntax`, `invalid_json_schema`, `invalid_json`, `unsupported_media_type`, `payload_too_large`
- `unauthorized`, `not_permitted`, `secret_path_denied`
- `not_found`, `conflict`, `timeout`, `busy`, `rate_limited`

`patch` means “unified diff apply/parse failure” (not the endpoint name).

## Retry guidance

- `408 timeout`, `429 rate_limited`, `503 busy`: exponential backoff (e.g., 100ms, 250ms, 500ms, max 3-5 retries).
- `409 conflict`: fetch latest version and retry with fresh `expected_version`.
- `400/401/403/415`: fix request/policy first; do not blind-retry.


---
file: docs/src/storage.md
title: "Storage Backends"
section_id: "docs-src-storage-md"
---

# Storage Backends

## Backend configuration matrix

| Backend | Key config | Default / behavior |
| --- | --- | --- |
| SQLite | `limits.max_io_ms` | used for busy timeout (capped) |
| SQLite | `limits.max_db_connections` | r2d2 pool size |
| Postgres | `limits.max_io_ms` | sets statement timeout |
| Postgres | `limits.max_db_connections` | r2d2 pool size |

## Timeout behavior

| Backend | Timeout mechanism | On timeout |
| --- | --- | --- |
| SQLite | service wall-clock + interrupt handle | best-effort interrupt, may finish shortly in background |
| Postgres | service wall-clock + statement timeout | query canceled by DB timeout rules |

Retry decision still depends on operation semantics (`conflict`, idempotency, etc).

## Migration contract

- migrations run at service startup;
- migration failure aborts startup;
- migrations are expected to be idempotent for existing environments;
- startup order: open connection -> run migrations -> serve traffic.

## Quick verification

SQLite:

```bash
cargo run -p db-vfs-service -- --sqlite ./db.sqlite --policy ./policy.local.toml
```

Postgres:

```bash
cargo run -p db-vfs-service --features postgres -- \
  --postgres 'postgres://user:pass@localhost:5432/db_vfs' \
  --policy ./policy.local.toml
```

After startup, run one `write` and one `read` request and verify 2xx responses.


---
file: docs/src/security.md
title: "Security"
section_id: "docs-src-security-md"
---

# Security

## Minimum security baseline

Use this checklist for production:

- [ ] run behind HTTPS/TLS end-to-end;
- [ ] keep auth enabled (do **not** use `--unsafe-no-auth`);
- [ ] scope tokens with `allowed_workspaces` (avoid `*`);
- [ ] set rate limiting (`limits.max_requests_per_ip_per_sec` and burst);
- [ ] enable audit log with `audit.jsonl_path` and keep `audit.required = true`;
- [ ] run with restrictive file permissions/umask for SQLite.

## Terms

- **Direct access deny**: `secrets.deny_globs` blocks path operations.
- **Redaction**: `secrets.redact_regexes` rewrites output text.
- **Directory-probe semantics**: `dir/*` also applies to `dir/**` descendants.

## Untrusted mode checklist

When policy source is not trusted, run with `--trust-mode untrusted`:

- [ ] no env interpolation in policy;
- [ ] no env-backed auth tokens;
- [ ] no writes/patch/delete;
- [ ] no full scan;
- [ ] no audit path configuration;
- [ ] no `--unsafe-no-auth`.

## Reverse proxy note

Rate limiting uses TCP peer IP (not `x-forwarded-for`).

Recommended deployment pattern:

- enforce edge/gateway rate limits first;
- keep service rate limit as a second guardrail;
- avoid trusting spoofable forwarded headers unless handled by a trusted edge.


---
file: docs/src/observability.md
title: "Observability"
section_id: "docs-src-observability-md"
---

# Observability

## Request ID contract

`x-request-id` behavior:

- client-provided value is accepted if it matches `[A-Za-z0-9_-]{1,128}`;
- invalid/missing value is replaced by service-generated ID;
- response always returns `x-request-id`.

## Audit JSONL schema

Sample line:

```json
{"ts_ms":1738828800000,"request_id":"...","op":"write","status":200,"workspace_id":"w1","peer_ip":"127.0.0.1"}
```

Core fields:

| Field | Type | Required | Notes |
| --- | --- | --- | --- |
| `ts_ms` | u64 | yes | event timestamp |
| `request_id` | string | yes | request correlation ID |
| `op` | string | yes | `read/write/patch/delete/glob/grep` |
| `status` | u16 | yes | HTTP status |
| `workspace_id` | string | yes | `<unknown>` for early rejects |
| `peer_ip` | string|null | no | TCP peer IP when available |
| `error_code` | string|null | no | stable error code |

## `peer_ip` handling

- source: TCP peer address (`ConnectInfo<SocketAddr>`);
- no forwarded-header parsing;
- apply local retention policy according to compliance requirements.

## Logging levels

Recommended `RUST_LOG`:

- dev: `RUST_LOG=db_vfs_service=debug`
- test/staging: `RUST_LOG=db_vfs_service=info`
- prod: `RUST_LOG=db_vfs_service=warn`

## Audit operations

- keep audit file permissions restrictive (`600` or equivalent owner-only access);
- configure external log rotation;
- monitor disk usage;
- understand startup behavior difference between `audit.required=true/false`.


---
file: docs/src/troubleshooting.md
title: "Troubleshooting"
section_id: "docs-src-troubleshooting-md"
---

# Troubleshooting

Use this template for each failure:

`Symptom -> Likely cause -> Immediate checks -> Fix -> Retry? -> Success criteria`

## `401 unauthorized`

- Symptom: response `401` + `code=unauthorized`.
- Likely cause: missing/invalid bearer token.
- Immediate checks: `Authorization: Bearer <token>`, token hash in policy.
- Fix: align runtime token and policy token hash/env var.
- Retry: yes, after fixing auth.
- Success criteria: request returns expected 2xx/4xx business result.

## `403 forbidden`

- Symptom: `403` with `not_permitted` / `secret_path_denied`.
- Likely cause: policy blocks operation or workspace/path.
- Immediate checks: `permissions.*`, `allowed_workspaces`, `secrets.deny_globs`.
- Fix: adjust policy for intended scope.
- Retry: only after policy fix.
- Success criteria: operation succeeds on allowed workspace/path.

## `409 conflict`

- Symptom: CAS mismatch.
- Likely cause: stale `expected_version`.
- Immediate checks: read latest file/version first.
- Fix: retry with latest version and idempotent write/patch logic.
- Retry: yes.
- Success criteria: update/delete accepted with current version.

## `408 timeout`

- Symptom: `timeout` under load or large requests.
- Likely cause: `limits.max_io_ms` too low or backend contention.
- Immediate checks: server logs with `request_id`, DB health, pool saturation.
- Fix: tune limits and query scope; reduce request payload/scan scope.
- Retry: yes, exponential backoff (3-5 attempts max).
- Success criteria: sustained requests complete within budget.

## `429 rate_limited`

- Symptom: `rate_limited`.
- Likely cause: per-IP burst exhausted.
- Immediate checks: caller request rate, gateway throttling.
- Fix: throttle caller and tune rate-limit policy.
- Retry: yes, with backoff and jitter.
- Success criteria: no repeated immediate 429 for steady traffic.

## `503 busy`

- Symptom: `busy` at peak concurrency.
- Likely cause: semaphore/pool saturation.
- Immediate checks: `limits.max_concurrency_io`, `max_concurrency_scan`, `max_db_connections`.
- Fix: tune concurrency, reduce expensive operations.
- Retry: yes, with bounded retries.
- Success criteria: queue drains and requests recover to normal latencies.

## `415 unsupported_media_type`

- Symptom: `code=unsupported_media_type`.
- Likely cause: missing/invalid JSON content type.
- Immediate checks: `content-type: application/json`.
- Fix: send proper JSON headers/body.
- Retry: yes after fixing request format.
- Success criteria: parser reaches business handler.


---
file: docs/src/development.md
title: "Development"
section_id: "docs-src-development-md"
---

# Development

## Prerequisites

Run all commands from repository root.

Required tools:

- Rust toolchain (`rustc`, `cargo`)
- `mdbook` (for docs build)

## Validation gates

### `./scripts/gate.sh`

Purpose: format/check/clippy/tests/docs/LLMS checks.

Pass criteria:

- exit code `0`
- no `error:` lines in output

Common failures:

- stale lockfile/features -> run targeted `cargo check` locally first
- stale llms bundle -> run `./scripts/llms.sh`

### `./scripts/docs.sh`

Purpose: build mdBook docs.

Pass criteria: exit code `0` and generated `docs/book/` output.

### `./scripts/llms.sh --check`

Purpose: ensure `llms.txt` and `docs/llms.txt` are up to date.

Pass criteria: reports `llms: up to date`.

## Git hooks

Enable local hooks:

```bash
./scripts/setup-githooks.sh
```

Hooks are local fast-fail checks; CI remains the merge authority.

Policy for `CHANGELOG.md` updates:

- user-visible/security behavior changes: required
- internal-only refactors/chore: may be grouped into one entry

## Docs and Pages troubleshooting

If docs deploy does not happen, check:

1. workflow trigger branch/path filters;
2. GitHub Pages settings (GitHub Actions source);
3. workflow permissions for pages/id-token.


---
file: docs/src/llms.md
title: "LLM Context (llms.txt)"
section_id: "docs-src-llms-md"
---

# LLM Context (`llms.txt`)

This repository maintains two synchronized bundle files:

- `llms.txt` (root, canonical generated output)
- `docs/llms.txt` (copy for docs distribution)

## Maintenance rules

- Source of truth for content is normal docs/README/SECURITY files.
- `llms.txt` and `docs/llms.txt` are generated artifacts.
- Do not hand-edit generated bundle files.

## Regenerate

```bash
./scripts/llms.sh
```

Expected result:

- root and docs copies are rewritten with identical content
- metadata header includes generation timestamp and source commit

Verify in CI/local:

```bash
./scripts/llms.sh --check
```

If check fails, regenerate then commit updated bundles.

## Front matter template

```yaml
---
title: db-vfs docs bundle
generated_at_utc: 2026-02-06T00:00:00Z
source_commit: <git-sha>
generator_version: scripts/llms.sh@v2
---
```

## Safe usage note

Before pasting bundle content into any LLM tool, remove sensitive values (tokens, credentials,
internal-only secrets, private URLs).

