# db-vfs — LLM documentation bundle

This file is generated from the repo sources to make RAG/LLM ingestion easier.
It follows `docs/src/SUMMARY.md` for the docs ordering.

Update it by running:

  ./scripts/llms.sh

---
file: README.md
---

# db-vfs

DB-backed “virtual filesystem” (DB-VFS) intended for server / high-concurrency workloads.

Goals:

- Preserve the explicit safety model shape: **Policy + Secrets + Limits**.
- Provide tool-like operations: `read`, `glob`, `grep`, `write`, `patch`, `delete`.
- Support SQLite (dev/test) and Postgres (production).

This is intentionally *not* part of `safe-fs-tools` to keep that crate focused on local OS
filesystem semantics and a small dependency graph.

## Documentation

- Human docs (mdBook sources): `docs/` (build with `./scripts/docs.sh`)
- LLM/RAG bundle: `llms.txt` and `docs/llms.txt` (regenerate with `./scripts/llms.sh`)

## Semantics

- `workspace_id` is the namespace boundary (like a “workspace root”).
- All `path`/`path_prefix` values are **root-relative**:
  - Must not start with `/`
  - Must not contain `..`
  - `path_prefix` may be empty (`""`) to mean “the whole workspace” **only if**
    `policy.permissions.allow_full_scan = true`
- Scope control (`path_prefix`):
  - `grep` requires an explicit `path_prefix` unless a safe literal prefix can be derived from
    `glob` (e.g. `"docs/**/*.md"` → `"docs/"`).
  - `glob` similarly requires `path_prefix` for broad patterns without a safe literal prefix (e.g.
    `"**/*.md"`).
- Concurrency control (`expected_version` / CAS):
  - `read` returns a `version`.
  - `patch` requires `expected_version`.
  - `write(expected_version = None)` is **create-only**; updates require `expected_version`.
  - `delete(expected_version = Some(v))` enforces CAS; `delete(expected_version = None)` is
    unconditional.

## HTTP service

By default the service requires an auth token configured in the policy file (`[auth]`), and each
token can be restricted to a workspace allowlist. For local development only, you can run with
`--unsafe-no-auth`.

Notes:

- Auth tokens:
  - Prefer storing only a hash in the policy: `sha256:<64 hex chars>`.
  - Or load a plaintext token from an environment variable: `auth.tokens[].token_env_var = "DB_VFS_TOKEN"`.
  - `--unsafe-no-auth` is restricted to loopback binds by default; use `--unsafe-no-auth-allow-non-loopback` only if you fully understand the risk.
- Request tracing uses `x-request-id`:
  - If the client sets it, the service echoes it back.
  - Otherwise the service generates one and returns it in the response headers.
- Concurrency and pooling are controlled by policy `limits`:
  - `max_concurrency_io` (read/write/patch/delete)
  - `max_concurrency_scan` (glob/grep)
  - `max_db_connections` (SQLite/Postgres pool size)
  - `max_io_ms` (service timeout for read/write/patch/delete; also used for Postgres `statement_timeout`)
- Rate limiting is controlled by policy `limits`:
  - `max_requests_per_ip_per_sec`
  - `max_requests_burst_per_ip`
  - Note: the limiter uses the TCP peer address (it does not parse `x-forwarded-for`), so configure it appropriately when running behind a reverse proxy.
- Scan traversal skipping is controlled by policy `traversal`:
  - `traversal.skip_globs` (performance only; does not deny direct access)
- Timeout semantics:
  - Timeouts are best-effort wall-clock budgets at the service layer.
  - Timeouts include time spent waiting for the service concurrency semaphores; under sustained load a request may fail with `503 busy` rather than wait indefinitely.
  - For SQLite, the service attempts to interrupt in-flight queries on timeout; for Postgres, `statement_timeout` is configured.
  - A timed-out request may still return early while some cleanup continues briefly in the background.
- Secrets are denied by default (e.g. `.env`, `.git/**`, `.ssh/**`, `.aws/**`, `.kube/**`, `.omne_agent_data/**`); adjust `policy.secrets` if needed.

### SQLite

Run:

```bash
cd db-vfs
cargo run -p db-vfs-service -- \
  --sqlite ./db-vfs.sqlite \
  --policy ./policy.example.toml \
  --listen 127.0.0.1:8080
```

### Postgres

Run (requires building with `postgres` enabled):

```bash
cd db-vfs
cargo run -p db-vfs-service --features postgres -- \
  --postgres "postgres://user:pass@localhost:5432/db_vfs" \
  --policy ./policy.example.toml \
  --listen 127.0.0.1:8080
```

Endpoints (JSON POST):

- `/v1/read`
- `/v1/write`
- `/v1/patch`
- `/v1/delete`
- `/v1/glob`
- `/v1/grep`

Minimal example:

```bash
curl -sS http://127.0.0.1:8080/v1/write \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","path":"docs/a.txt","content":"hello","expected_version":null}'

curl -sS http://127.0.0.1:8080/v1/grep \
  -H 'content-type: application/json' \
  -H "authorization: Bearer ${DB_VFS_TOKEN}" \
  -d '{"workspace_id":"w1","query":"hello","regex":false,"glob":"docs/**/*.txt","path_prefix":null}'
```

## Development

Run gates (fmt/check/clippy/test):

```bash
./scripts/gate.sh
```

Enable git hooks:

```bash
git config core.hooksPath githooks
```

The hooks enforce Conventional Commits and require `CHANGELOG.md` updates. The Rust file size guard
can be overridden via `DB_VFS_MAX_RS_LINES=<N>`.


---
file: policy.example.toml
---

[permissions]
read = true
glob = true
grep = true
write = false
patch = false
delete = false
allow_full_scan = false

# Service auth (recommended).
#
# Requests must include:
#   Authorization: Bearer <token>
#
# Each token can be restricted to a workspace allowlist:
# - exact: "ws1"
# - prefix: "team1-*"
# - all: "*"
#
# Token values can be provided as plaintext (via env var) or stored as a SHA-256 hash:
# - Prefer storing only a SHA-256 hash in committed policies:
#     token = "sha256:<64 hex chars>"
# - Or load a plaintext token from an environment variable at runtime:
#     token_env_var = "DB_VFS_TOKEN"
#
# NOTE: don't commit real tokens.
[auth]
[[auth.tokens]]
token_env_var = "DB_VFS_TOKEN"
allowed_workspaces = ["*"]

# All limits have defaults; override as needed.
#
[limits]
# Recommended for production-ish deployments:
max_walk_ms = 2000

# Per-IP token-bucket rate limiting (set 0/0 to disable).
max_requests_per_ip_per_sec = 100
max_requests_burst_per_ip = 200
# Cap the number of distinct IPs tracked by the limiter.
max_rate_limit_ips = 65536

# Secrets are enabled by default in code, but can be customized here:
#
# [secrets]
# deny_globs = [".git/**", "**/.git/**", ".env", ".env.*", "**/.env", "**/.env.*", ".ssh/**", "**/.ssh/**", ".aws/**", "**/.aws/**", ".kube/**", "**/.kube/**", ".npmrc", "**/.npmrc", ".netrc", "**/.netrc", ".pypirc", "**/.pypirc", ".cargo/credentials", "**/.cargo/credentials", ".docker/config.json", "**/.docker/config.json", ".omne_agent_data/**", "**/.omne_agent_data/**"]
# redact_regexes = []
# replacement = "***REDACTED***"

# Scan traversal skip globs (performance only; does not deny direct access).
#
# [traversal]
# skip_globs = ["target/**", "**/target/**", "node_modules/**", "**/node_modules/**"]


---
file: SECURITY.md
---

# Security

## Threat model

`db-vfs` is a library + HTTP service for performing virtual filesystem operations against a
database-backed store with an explicit, caller-provided policy (`VfsPolicy`).

It enforces policy checks in-process. It is designed for *trusted* deployments (e.g. internal
services) where you still want strong, explicit guardrails.

## Not an OS sandbox

This project does **not** provide OS-level isolation. If you need strong isolation, run the service
inside an OS sandbox / container / VM and apply network controls.

## Auth & secrets

- The service requires `Authorization: Bearer <token>` by default.
- Prefer storing only `sha256:<64 hex>` token hashes in committed policy files.
- For plaintext tokens, use `auth.tokens[].token_env_var` so secrets live in the process environment.
- `--unsafe-no-auth` is restricted to loopback binds by default; using it on a public interface is
  dangerous.

Secrets are mitigated via:

- Path deny rules (`policy.secrets.deny_globs`) to block direct access.
- Regex redaction (`policy.secrets.redact_regexes`) applied to `read`/`grep` output.

## Resource limits & DoS

Policy limits bound work and memory:

- Request sizes: `max_read_bytes`, `max_write_bytes`, `max_patch_bytes`.
- Scan bounds: `max_walk_entries`, `max_walk_files`, `max_walk_ms`, `max_results`.
- Service concurrency: `max_concurrency_io`, `max_concurrency_scan`, `max_db_connections`.
- Service timeouts: `max_io_ms` (plus Postgres `statement_timeout` when enabled).
- Per-IP rate limiting: `max_requests_per_ip_per_sec`, `max_requests_burst_per_ip`,
  `max_rate_limit_ips`.

These are best-effort safeguards, not a replacement for OS-level limits and network-level
mitigations (load balancers, WAF, reverse proxy rate limits, etc.).

## Timeout semantics

Service-layer timeouts return early to the client, but the underlying blocking DB operation may
continue briefly in the background. For SQLite, the service attempts to interrupt in-flight queries
on timeout; for Postgres, `statement_timeout` is configured. Treat timeouts as a *budgeting* and
*backpressure* mechanism, not a hard cancel.

## Path probing side-channels

If untrusted callers can control `path` inputs and observe detailed errors/timing, they may be able
to infer information about stored paths (existence, deny rules, etc.).

If this matters, reduce observable error detail, enforce rate limits, and run behind an API gateway.

## Reporting

If you discover a security issue, please open an issue with:

- Minimal reproduction
- Expected vs actual behavior
- Environment details (OS, Rust toolchain, DB backend)


---
file: docs/src/SUMMARY.md
---

# Summary

* [Introduction](index.md)
* [Getting started](getting-started.md)
* [Concepts](concepts.md)
* Guides
  * [Policy](policy.md)
  * [HTTP API](http-api.md)
  * [Storage backends](storage.md)
  * [Security](security.md)
  * [Observability](observability.md)
  * [Troubleshooting](troubleshooting.md)
  * [Development](development.md)
  * [`llms.txt`](llms.md)

